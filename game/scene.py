import pygame

from _1systems.input_manager_system import InputManager
from _3gameobjs.map import Map
from _3gameobjs.player import Player
from rendering_layer import RenderingLayer
from _3gameobjs.test_obj import TestObj
from _1systems.scalable_game_screen_system import ScalableGameScreen


class Camara:

    def __init__(self, rendering_layers_to_render: list[RenderingLayer], followed_game_object=None):
        self._rendering_layers_to_render = rendering_layers_to_render
        self._followed_game_object = followed_game_object
        # the movement off-set base on the followed game object
        self.followed_object_offset = pygame.Vector2()
    
    def follow_game_object(self, game_object):
        self._followed_game_object = game_object
    def stop_following_current_set_game_object(self):
        self._followed_game_object = None

    def render_layers(self):

        if self._followed_game_object is not None:

            # essential for moving, its the difference of the followed game obj position in relation to the screen,
            # in other words, how much should every other game object should move on screen (not on world)
            self.followed_object_offset.x = self._followed_game_object.transform.world_position.x - ScalableGameScreen.HalfDummyScreenWidth
            self.followed_object_offset.y = self._followed_game_object.transform.world_position.y - ScalableGameScreen.HalfDummyScreenHeight

            for r_layer in self._rendering_layers_to_render:
                for game_obj in r_layer.game_objects_to_render_read_only:

                    # the final result of the render takes in consideration the game object world position
                    # that's why I pre-update the image_rect
                    game_obj.image_rect = game_obj.image.get_rect(center=game_obj.transform.world_position)

                    # the followed game object must be treated in a different way
                    if game_obj != self._followed_game_object:

                        # fixed on screen game objects are simply rendered at their fixed position on screen
                        # by setting their image_ret to that fixed position
                        if game_obj.is_fixed_on_screen:
                            game_obj.image_rect.center = game_obj.fixed_position_on_screen

                        # non fixed on screen objects have to be moved according to the offset generated by the followed object
                        # so their image_rect is updated subtracting the offset.
                        else:
                            game_obj.image_rect.center -= self.followed_object_offset

                    # updates the sprite image_rect position the followed game object image rect ,
                    # it's different from the orders because it's always n the center
                    else:
                        screen_center = (ScalableGameScreen.HalfDummyScreenWidth, ScalableGameScreen.HalfDummyScreenHeight)
                        self._followed_game_object.image_rect = self._followed_game_object.image.get_rect(center=screen_center)

                    # render the game object on screen according to its screen position (not world position) a.k.a. image_rect position
                    if game_obj.should__be_rendered:
                        ScalableGameScreen.GameScreenDummySurface.blit(game_obj.image, game_obj.image_rect)

                    # - Should be the last thing executing at the rendering system
                    # - Just updates what is show at the transform for extra accuracy
                    # - Nice to mention, the transform is just a way the get the screen position easily, it doesn't change it
                    # - Also updates if is appearing on screen
                    game_obj.transform.component_update()

        # if there is no game object being followed, the camera simply renders everything at its
        # img_rect position without calculating off-set
        else:
            for r_layer in self._rendering_layers_to_render:
                for game_obj in r_layer.game_objects_to_render_read_only:
                    game_obj.image_rect = game_obj.image.get_rect(center=game_obj.transform.world_position)
                    if game_obj.is_fixed_on_screen:
                        game_obj.image_rect.center = game_obj.fixed_position_on_screen
                    if game_obj.should__be_rendered:
                        ScalableGameScreen.GameScreenDummySurface.blit(game_obj.image, game_obj.image_rect)
                        game_obj.transform.component_update()


class Scene:

    def __init__(self, game):

        self.game = game

        """ 
        LIST USED FOR UPDATES:
            - It holds all game objects of the scene
            - When a game Obj is instantiated, it's automatically stored here using the scene passed as parameter in 
              its constructor """
        self.all_game_obj = []

        # - When a game Obj is instantiated, it's automatically stored here using the layer passed as parameter in its constructor
        self.rendering_layer_map = RenderingLayer()
        self.rendering_layer_test = RenderingLayer()
        self.rendering_layer_player = RenderingLayer()
        self.rendering_layer_tools = RenderingLayer()
        self.rendering_layers = [self.rendering_layer_map, self.rendering_layer_test, self.rendering_layer_player, self.rendering_layer_tools]

        self.scene_start()  # called once

        # game objects
        self.map = Map("map", self, self.rendering_layer_map)
        self.player = Player("game_player", self, self.rendering_layer_player)
        self.player.transform.move_world_position(pygame.Vector2(500, 500))
        self.test_obj = TestObj("test_obj_1", self, self.rendering_layer_test)

        # main camera will render the rendering layers
        self.main_camera = Camara(self.rendering_layers)

    def scene_start(self):
        pass

    def scene_update(self):
        # first updates the components then the game object itself
        for gm in self.all_game_obj:
            for component in gm.components_list:
                component.component_update()
            gm.game_object_update()

    def scene_render(self):
        # clears the screen for rendering
        ScalableGameScreen.GameScreenDummySurface.fill("darkgreen")
        # renders all rendering layers
        self.main_camera.render_layers()

        # for testing the camera
        if InputManager.is_key_pressed(pygame.K_q):
            self.main_camera.follow_game_object(self.player)
        if InputManager.is_key_pressed(pygame.K_e):
            self.main_camera.stop_following_current_set_game_object()

    # CALLED BY THE InspectorDebuggingCanvas to show this text at the inspector
    def get_inspector_debugging_status(self) -> str:
        return f"SCENE DEBUGGING STATUS\n" \
               f"total rendering layers: {len(self.rendering_layers)}\n" \
               f"total game objects: {len(self.all_game_obj)}\n"

